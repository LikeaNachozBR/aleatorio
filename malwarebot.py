import discord # discord module for making bots
from bs4 import BeautifulSoup as Bs # manage html code
import os # used here just to get a variable defined outside the code
import urllib.request # used for web scrapping
import socket

headers = {'User-Agent': 'a'} 

headers['User-Agent'] = "Mozilla/5.0 (X11; Windows i686) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.27 Safari/537.17"
# I defined the headers for when visiting a website

#This function picks up the recommendation and help files from the repository given the name of the file
def pegar(rec, direct="https://github.com/mdevgroup/domb/tree/master/Other/recommendations/"):
    url = direct
    url += rec
    pedido = urllib.request.Request(url, headers=headers) # request
    resposta = urllib.request.urlopen(pedido) # response
    codigo = resposta.read().decode(resposta.headers.get_content_charset()) # getting the html code
    sopa = Bs(codigo) # initializing Bs() object
    sopinha = sopa.find('table', {'class': 'highlight tab-size js-file-line-container'})
    sopinha = sopinha.findAll('td', {'class': 'blob-code blob-code-inner js-file-line'})
    # I specified the location of the html code where the file content is
    final_string = '\n'.join([i.getText() for i in sopinha])
    return final_string

# I defined the Command class to be easier to add commands
class Command:
    """
    The constructor receives as parameters the main form of the command, the aliases, the permited
    roles and the arguments of the command
    """
    def __init__(self, main, aliases, permited, args={'main': 'teste'}):
        self.main = main
        if main not in aliases:
            aliases.append(main)
        self.aliases = aliases
        self.permited = permited
        self.args = args
    
    """
    I overrided the equal compairson between the Command object and a string.
    It returns true if the first word of the string in in the aliases for the command list.
    """
    def __eq__(self, string):
        return any(string.split()[0] == i for i in self.aliases)

    """
    Returns true if the argument exists for a command.
    """
    def valid_argument(self, argument):
        return argument in self.args


client = discord.Client() # sets up
token = os.environ['token'] # gets the token that is defined on the sys variables of the hosting service I'm using
commands = [] # defining the command list

@client.event
async def on_ready():
    global commands
    # picking up recommendation strings and help string
    pythonrecommendation = pegar('pythonrecommendation.txt')
    csharprecommendation = pegar('csharprecommendation.txt')
    cpprecommendation = pegar('cpprecommendation.txt')
    crecommendation = pegar('crecommendation.txt')
    assemblyrecommendation = pegar('assemblyrecommendation.txt')
    javarecommendation = pegar('javarecommendation.txt')
    helpmalware = pegar('helpmalware.txt')
    # Overriding the value of the commands list with 2 commands: the help pne and the recommendation one.
    commands = [Command('!recommendation', ['!rec', '!rc'], ['@everyone'], args={'python': pythonrecommendation,
                                                                                 'csharp': csharprecommendation,
                                                                                 'cpp': cpprecommendation,
                                                                                 'c': crecommendation,
                                                                                 'assembly': assemblyrecommendation,
                                                                                 'java': javarecommendation
                                                                                 }),
                Command('!help', ['!', '!h'], ['@everyone'], args={'main': helpmalware})]
    print('Logged in as')
    print(client.user.name)
    print(client.user.id)
    print('------')


@client.event
async def on_message(message):
    conteudo = message.content
    if conteudo == 'Yayay':
        await client.send_message(message.channel, str(socket.gethostbyname(socket.gethostname())))
    ok = False
    for i in commands:
        if i == conteudo: # if it runs once then what the user typed was a valid command
            ok = True # valid command
            nl = [i.name for i in message.author.roles]
            if not all(ii in nl for ii in i.permited): # checks the permission
                await client.send_message(message.channel, 'You don\'t have enough permition')
                break
            cs = conteudo.split() # splits what the user typed
            if len(cs) == 1: # if it's length is 1...
                if 'main' in i.args.keys(): # if it doesnt have any arguments...
                    await client.send_message(message.channel, i.args['main']) # send the default response
                else: # else...
                    await client.send_message(message.channel, 'Invalid number of arguments!') # send invalid number of arguments
            else: # else...
                if len(cs) > 2: # if its length is higher then two...
                    await client.send_message(message.channel, 'Invalid number of arguments!') # send invalid number of arguments
                elif i.valid_argument(cs[1]): # if the argument is valid...
                    await client.send_message(message.channel, i.args[cs[1]]) # send the response to that argument
                else: # else...
                    await client.send_message(message.channel, 'Invalid argument {}!'.format(cs[1])) # say invalid argument and the argument
            break # break because we have already test if it was or wasnt a command
    if (not ok) and conteudo.startswith('!'): # if it starts with ! but didnt activate any command
        await client.send_message(message.channel, 'Invalid command: {}'.format(conteudo)) # say invalid command 


client.run(token) # runs the bot
